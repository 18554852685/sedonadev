//
// Copyright (c) 2007 Tridium, Inc.
// Licensed under the Academic Free License version 3.0
//
// History:
//   3 Mar 07  Brian Frank  Creation
//

#include "sedona.h"
#ifdef USE_STANDARD_MAIN

//Titus : includes for sedona
#include <stdio.h>
#include <stdlib.h>
#include "errorcodes.h"

//needed to pass version info from gcc command line as a string value (only needed for QNX)
#define VER1(x) #x
#define VER(x) VER1(x)
//#define VER VER_(PLAT_BUILD_VERSION)




// sys::Sys forward
int64_t sys_Sys_ticks(SedonaVM* vm, Cell* params);
void sys_Sys_sleep(SedonaVM* vm, Cell* params);

int64_t yieldNs = 0;

// forwards
static int printUsage(const char* exe);
static int printVersion();
static int loadFile(const char* filename, uint8_t** addr, size_t* size);
static void checkStaged(const char* filename);
static void onAssertFailure(const char* location, uint16_t linenum);
static int  commonVmSetup(SedonaVM* vm, const char* scodeFile);
static int  runInPlatformMode();
static int  runInStandaloneMode(const char* filename, int vmArgc, char* vmArgv[]);

// auto-generated by sedonac in "nativetable.c"
extern NativeMethod* nativeTable[];


#if 0
/** @file server/main.c  Example server application using the BACnet Stack. */

/* (Doxygen note: The next two lines pull all the following Javadoc
 *  into the ServerDemo module.) */
/** @addtogroup ServerDemo */
/*@{*/

/** Buffer used for receiving */
static uint8_t Rx_Buf[MAX_MPDU] = { 0 };

/** Initialize the handlers we will utilize.
 * @see Device_Init, apdu_set_unconfirmed_handler, apdu_set_confirmed_handler
 */
static void Init_Service_Handlers(
    void)
{
    Device_Init(NULL);
    /* we need to handle who-is to support dynamic device binding */
    apdu_set_unconfirmed_handler(SERVICE_UNCONFIRMED_WHO_IS, handler_who_is);
    apdu_set_unconfirmed_handler(SERVICE_UNCONFIRMED_WHO_HAS, handler_who_has);
    /* handle i-am to support binding to other devices */
    apdu_set_unconfirmed_handler(SERVICE_UNCONFIRMED_I_AM, handler_i_am_bind);
    /* set the handler for all the services we don't implement */
    /* It is required to send the proper reject message... */
    apdu_set_unrecognized_service_handler_handler
        (handler_unrecognized_service);
    /* Set the handlers for any confirmed services that we support. */
    /* We must implement read property - it's required! */
    apdu_set_confirmed_handler(SERVICE_CONFIRMED_READ_PROPERTY,
        handler_read_property);
    apdu_set_confirmed_handler(SERVICE_CONFIRMED_READ_PROP_MULTIPLE,
        handler_read_property_multiple);
    apdu_set_confirmed_handler(SERVICE_CONFIRMED_WRITE_PROPERTY,
        handler_write_property);
    apdu_set_confirmed_handler(SERVICE_CONFIRMED_WRITE_PROP_MULTIPLE,
        handler_write_property_multiple);
    apdu_set_confirmed_handler(SERVICE_CONFIRMED_READ_RANGE,
        handler_read_range);
#if defined(BACFILE)
    apdu_set_confirmed_handler(SERVICE_CONFIRMED_ATOMIC_READ_FILE,
        handler_atomic_read_file);
    apdu_set_confirmed_handler(SERVICE_CONFIRMED_ATOMIC_WRITE_FILE,
        handler_atomic_write_file);
#endif
    apdu_set_confirmed_handler(SERVICE_CONFIRMED_REINITIALIZE_DEVICE,
        handler_reinitialize_device);
    apdu_set_unconfirmed_handler(SERVICE_UNCONFIRMED_UTC_TIME_SYNCHRONIZATION,
        handler_timesync_utc);
    apdu_set_unconfirmed_handler(SERVICE_UNCONFIRMED_TIME_SYNCHRONIZATION,
        handler_timesync);
    apdu_set_confirmed_handler(SERVICE_CONFIRMED_SUBSCRIBE_COV,
        handler_cov_subscribe);
    apdu_set_unconfirmed_handler(SERVICE_UNCONFIRMED_COV_NOTIFICATION,
        handler_ucov_notification);
    /* handle communication so we can shutup when asked */
    apdu_set_confirmed_handler(SERVICE_CONFIRMED_DEVICE_COMMUNICATION_CONTROL,
        handler_device_communication_control);
    /* handle the data coming back from private requests */
    apdu_set_unconfirmed_handler(SERVICE_UNCONFIRMED_PRIVATE_TRANSFER,
        handler_unconfirmed_private_transfer);
#if defined(INTRINSIC_REPORTING)
    apdu_set_confirmed_handler(SERVICE_CONFIRMED_ACKNOWLEDGE_ALARM,
        handler_alarm_ack);
    apdu_set_confirmed_handler(SERVICE_CONFIRMED_GET_EVENT_INFORMATION,
        handler_get_event_information);
    apdu_set_confirmed_handler(SERVICE_CONFIRMED_GET_ALARM_SUMMARY,
        handler_get_alarm_summary);
#endif /* defined(INTRINSIC_REPORTING) */
}
#endif



////////////////////////////////////////////////////////////////
// Main
////////////////////////////////////////////////////////////////

//Titus : Need to declare as global
  bool runAsPlatform = FALSE;

int main(int argc, char *argv[])
{

  int i;
//Titus
//  bool runAsPlatform = FALSE;
  char* filename = NULL;
  int optCount = 0;

//Titus : disable bacnet
#if 0

  printf("Running SEDONA + BACNET stacks...\n");


    BACNET_ADDRESS src = {
        0
    };  /* address where message came from */
    uint16_t pdu_len = 0;
    unsigned timeout = 1;       /* milliseconds */
    time_t last_seconds = 0;
    time_t current_seconds = 0;
    uint32_t elapsed_seconds = 0;
    uint32_t elapsed_milliseconds = 0;
    uint32_t address_binding_tmr = 0;
    uint32_t recipient_scan_tmr = 0;

    /* allow the device ID to be set */
    if (argc > 1)
        Device_Set_Object_Instance_Number(strtol(argv[1], NULL, 0));
    printf("BACnet Server Demo\n" "BACnet Stack Version %s\n"
        "BACnet Device ID: %u\n" "Max APDU: %d\n", BACnet_Version,
        Device_Object_Instance_Number(), MAX_APDU);
    /* load any static address bindings to show up
       in our device bindings list */
    address_init();
    Init_Service_Handlers();
    dlenv_init();
    atexit(datalink_cleanup);
    /* configure the timeout values */
    last_seconds = time(NULL);
    /* broadcast an I-Am on startup */
    Send_I_Am(&Handler_Transmit_Buffer[0]);

    /* Create independent threads each of which will execute function */

     iret1 = pthread_create( &thread1, NULL, print_message_function, (void*) message1);
     if(iret1)
     {
         fprintf(stderr,"Error - pthread_create() return code: %d\n",iret1);
         exit(EXIT_FAILURE);
     }

#if 1
//Titus : local open bracket
{

     printf("%s CALLED\n", message2);

    /* loop forever */
    for (;;) {
        /* input */
        current_seconds = time(NULL);

        /* returns 0 bytes on timeout */
        pdu_len = datalink_receive(&src, &Rx_Buf[0], MAX_MPDU, timeout);

        /* process */
        if (pdu_len) {
            npdu_handler(&src, &Rx_Buf[0], pdu_len);
        }
        /* at least one second has passed */
        elapsed_seconds = (uint32_t) (current_seconds - last_seconds);
        if (elapsed_seconds) {
            last_seconds = current_seconds;
            dcc_timer_seconds(elapsed_seconds);
#if defined(BACDL_BIP) && BBMD_ENABLED
            bvlc_maintenance_timer(elapsed_seconds);
#endif
            dlenv_maintenance_timer(elapsed_seconds);
            Load_Control_State_Machine_Handler();
            elapsed_milliseconds = elapsed_seconds * 1000;
            handler_cov_timer_seconds(elapsed_seconds);
            tsm_timer_milliseconds(elapsed_milliseconds);
            trend_log_timer(elapsed_seconds);
#if defined(INTRINSIC_REPORTING)
            Device_local_reporting();
#endif
        }
        handler_cov_task();
        /* scan cache address */
        address_binding_tmr += elapsed_seconds;
        if (address_binding_tmr >= 60) {
            address_cache_timer(address_binding_tmr);
            address_binding_tmr = 0;
        }
#if defined(INTRINSIC_REPORTING)
        /* try to find addresses of recipients */
        recipient_scan_tmr += elapsed_seconds;
        if (recipient_scan_tmr >= NC_RESCAN_RECIPIENTS_SECS) {
            Notification_Class_find_recipient();
            recipient_scan_tmr = 0;
        }
#endif
        /* output */

        /* blink LEDs, Turn on or off outputs, etc */
    }

    return 0;
}//Titus : local close bracket
#endif

#endif //Titus : disable bacnet


  printf("Running SEDONA alone...\n");

  // parse arguments
  for (i=1; i<argc; ++i)
  {
    char* arg = argv[i];
    if (arg[0] == '-')
    {
      if (strcmp(arg, "--?") == 0)   return printUsage(argv[0]);
      if (strcmp(arg, "--ver") == 0) return printVersion();

      if (strcmp(arg, "--plat") == 0) runAsPlatform = TRUE;
      else if (strncmp(arg, "--home=", 7) == 0)
      {
        char* home = arg+7;
        if (strlen(arg) < 8) return printUsage(argv[0]);
        if (_chdir(home) != 0) return printUsage(argv[0]);
        optCount++;
      }
    }
    else
    {
      if (filename == NULL)
        filename = arg;
    }
  }

  printVersion();
  if (runAsPlatform)
  {
    return runInPlatformMode();
  }
  else
  {
    if (filename == NULL)
    {
      printUsage(argv[0]);
      return ERR_INPUT_FILE_NOT_FOUND;
    }
    return runInStandaloneMode(filename, argc - (2 + optCount), argv + (2+optCount));
  }
}


////////////////////////////////////////////////////////////////
// Platform VM
////////////////////////////////////////////////////////////////

static int runInPlatformMode()
{
  int result = 0;

//Titus : hard-coded the names to run the default *.sab and *.scode files in platform mode
//  const char* scode = "kits.scode";
//  const char* app   = "app.sab";

  const char* scode = "platRpi.scode";
  const char* app   = "platRpi.sab";


  SedonaVM vm;
  bool quit = FALSE;

  printf("Running SVM in Platform Mode\n");
  do
  {
    checkStaged(scode);
    checkStaged(app);

    if ((result = commonVmSetup(&vm, scode)) != 0)
      return result;
    vm.args     = (const char**)&app;
    vm.argsLen  = 1;

    result = vmRun(&vm);
    while ((result == ERR_HIBERNATE) || (result == ERR_YIELD))
    {
      //  Simulate hibernate and yield
      if (result == ERR_HIBERNATE)
        printf("-- Simulated hibernate --\n");       
      else
      {  
        sys_Sys_sleep(NULL, (Cell*)&yieldNs); 
        yieldNs = 0;
      }  
      
      
      result = vmResume(&vm);
    }

    if (result != 0)
    {
      if (result == ERR_RESTART)
        printf("Restarting VM\n\n");
      else
      {
        printf("Cannot run VM (%d)\n", result);
        quit = TRUE;
      }
    }
    else
    {
      printf("Quitting\n");
      quit = TRUE;
    }
  } while (!quit);

  return result;
}

////////////////////////////////////////////////////////////////
// Standalone VM
////////////////////////////////////////////////////////////////

static int runInStandaloneMode(const char* filename, int vmArgc, char* vmArgv[])
{
  int result;
  SedonaVM vm;
  int64_t t1, t2;

  if ((result = commonVmSetup(&vm, filename)) != 0)
    return result;

  // setup arguments
  vm.args = (const char**)(vmArgv);
  vm.argsLen = vmArgc;

  // run the VM
  t1 = sys_Sys_ticks(NULL, NULL);
  result = vmRun(&vm);

  while ((result == ERR_HIBERNATE) || (result == ERR_YIELD))
  {
    //  Simulate hibernate and yield    
    if (result == ERR_HIBERNATE)
    {  
      printf("-- Simulated hibernate --\n");             
    }  
    else
    { 
      printf("Simulate yield %lld ", yieldNs); 
      sys_Sys_sleep(NULL, (Cell*)&yieldNs);   
      yieldNs = 0;   
    }
    result = vmResume(&vm);
  }


  // done
  if (result != 0)
  {
    printf("Cannot run VM (%d)\n", result);
    return result;
  }
  t2 = sys_Sys_ticks(NULL, NULL);

  printf("\n");
  printf("VM Completed\n");
#ifdef _WIN32
  printf("Total Time       = %I64d ms\n", (t2-t1)/1000000i64);
#else
  printf("Total Time       = %lld ms\n", (t2-t1)/1000000ll);
#endif
  printf("Assert Successes = %d\n", vm.assertSuccesses);
  printf("Assert Failures  = %d\n", vm.assertFailures);
  printf("\n");
  if (vm.assertFailures == 0)
  {
    printf("--\n");
    printf("-- All tests passed\n");
    printf("--\n");
    return 0;
  }
  else
  {
    printf("--\n");
    printf("-- %d TESTS FAILED!!!\n", vm.assertFailures);
    printf("--\n");
    return vm.assertFailures;
  }

  return result;
}

////////////////////////////////////////////////////////////////
// Common VM Setup
////////////////////////////////////////////////////////////////

/**
 *
 * This function initialize the following fields of the VM.
 * 1) stackMaxSize
 * 2) stackBaseAddr
 * 3) onAssertFailure callback
 * 4) nativeTable
 * 5) call function pointer
 *
 * The following fields will still need to be initialized before
 * the VM can be run.
 * 1) args
 * 2) argsLen
 */
static int commonVmSetup(SedonaVM* vm, const char* scodeFile)
{
  int result;

  // load scode
  result = loadFile(scodeFile, (uint8_t**)&(vm->codeBaseAddr), &(vm->codeSize));
  if (result != 0)
  {
    printf("Cannot load input file (%d): %s\n", result, scodeFile);
    return result;
  }

  // alloc stack (hardcoded for now)
  vm->stackMaxSize  = 16384;
  vm->stackBaseAddr = (uint8_t*)malloc(vm->stackMaxSize);
  if (vm->stackBaseAddr == NULL)
  {
    printf("Cannot malloc stack segments\n");
    return ERR_MALLOC_STACK;
  }

  // setup callbacks
  vm->onAssertFailure = onAssertFailure;

  // setup native method table
  vm->nativeTable = nativeTable;

  // setup call function pointer
  vm->call = vmCall;
  return 0;
}

////////////////////////////////////////////////////////////////
// Print Usage
////////////////////////////////////////////////////////////////

static int printUsage(const char* exe)
{
  printf("usage:\n");
  printf("  %s [options] <scode file> [<sab file>] [<Sedona main args>]\n", exe);
  printf("  %s [options] --plat\n", exe);
  printf("options:\n");
  printf("  --?       dump usage\n");
  printf("  --ver     dump version\n");
  printf("  --home=d  set current working directory\n");
  printf("  --plat    run in platform mode. 'kits.scode[.stage]' and 'app.sab[.stage]'\n");
  printf("            must be present in the working directory\n");
  return 0;
}

////////////////////////////////////////////////////////////////
// Print Version
////////////////////////////////////////////////////////////////

#ifndef PLAT_BUILD_VERSION
 #error Must set PLAT_BUILD_VERSION
#endif 

static int printVersion()
{
#ifdef IS_BIG_ENDIAN
  const char* endian = "big";
#else
  const char* endian = "little";
#endif
  printf("\n");
#ifdef __QNX__
  printf("Sedona VM %s\n", VER(PLAT_BUILD_VERSION));
#else
  printf("Sedona VM %s\n", PLAT_BUILD_VERSION);
#endif
 
  printf("buildDate: %s %s\n", __DATE__, __TIME__);
  printf("endian:    %s\n", endian);
  printf("blockSize: %d\n", SCODE_BLOCK_SIZE);
  printf("refSize:   %d\n", sizeof(void*));
  printf("\n");
  return 0;
}

////////////////////////////////////////////////////////////////
// Load File
////////////////////////////////////////////////////////////////

static int loadFile(const char* filename, uint8_t** paddr, size_t* psize)
{
  size_t result;
  FILE* file;
  size_t size;
  uint8_t* addr;

  // open file
  file = fopen(filename, "rb");
  if (file == NULL) return ERR_INPUT_FILE_NOT_FOUND;

  // seek to end to get file size
  result = fseek(file, 0, SEEK_END);
  if (result != 0) return ERR_CANNOT_READ_INPUT_FILE;
  size = ftell(file);
  rewind(file);

  // allocate memory for image
  addr = (uint8_t*)malloc(size);
  if (addr == NULL)
    return ERR_MALLOC_IMAGE;

  // read file into memory
  result = fread(addr, 1, size, file);
  if (result != size) return ERR_CANNOT_READ_INPUT_FILE;

  // success
  *paddr = addr;
  *psize = size;
  fclose(file);
  return 0;
}

//////////////////////////////////////////////////////////////////////////
// Staged Files
//////////////////////////////////////////////////////////////////////////

/**
 * Checks if <filename>.stage exists. If so it is renamed to <filename>.
 */
static void checkStaged(const char* filename)
{
  FILE* file;
  size_t len;
  char* stageName;

  len = strlen(filename);
  stageName = (char*)malloc(len + strlen(".stage") + 1);
  strcpy(stageName, filename);
  strcat(stageName, ".stage");
  if ((file = fopen(stageName, "rb")) != NULL)
  {
    fclose(file);
    printf("Moving %s to %s\n", stageName, filename);
    remove(filename);
    rename(stageName, filename);
  }
  free(stageName);
}

//////////////////////////////////////////////////////////////////////////
// VM Callbacks
//////////////////////////////////////////////////////////////////////////

static void onAssertFailure(const char* location, uint16_t linenum)
{
  printf("ASSERT FAILURE: %s [Line %d]\n", location, linenum);
}

#endif
